#!/bin/sh -f

#
# bkm - bookmark manager
#

log() {
    printf '%s\n' "$@"
}

die() {
    log "$1"
    exit 1
}

nest() {
    log "├─ $1" \
        "│  $2"
}

msg() {
    log "$1" "$2"
    nest "$3" "$4"
}

truncate() {
    set +f
    # shellcheck disable=2048,2086
    set -f -- $*

    printf '%s\n' "$*"
}

trim() {
    printf '%s\n' "$1" | sed -e "s/ //g"
}

sanitize() {
    str=$1
    str=$(truncate "$str")
    str=$(trim "$str")

    printf '%s\n' "$str"
}

read_input() {
    old=$1

    read -r "new"

    if [ -n "$new" ] && [ "$new" != "$old" ]; then
        new=$(sanitize "$new")
        printf '%s\n' "$new"
    else
        printf '%s\n' "$old"
    fi

    unset old
    unset new
}

is_url() {
    printf '%s\n' "$1" | grep -q -e "http://" -e "https://" -e "www." && {
        return 0
    }

    return 1
}

url_or_die() {
    is_url "${1:-""}" || die "URL is required and must have valid format."
}

value_or_die() {
    [ -n "$1" ] || die "Argument $2 is required."
}

file_or_die() {
    [ -f "$1" ] || die "Category ${1##*/} not found."
}

git_or_die() {
    command -v git > /dev/null || die "This command requires git to be installed."
}

repo_or_die() {
    command git rev-parse --is-inside-work-tree 1> /dev/null 2> /dev/null || {
        die "\$BKM_DIR is not a git repository."
    }
}

remote_or_die() {
    command git remote -v > /dev/null && {
        die "\$BKM_DIR remote repository not set."
    }
}

is_dirty() {
    git status --short > /dev/null && return 0

    return 1
}

dirty_or_die() {
    is_dirty || die "\$BKM_DIR git repository is clean."
}

list_tree() {
    file_or_die "$1"

    log "${1##*/}"

    while IFS=' ' read -r n u; do
        nest "$n" "$u"
    done < "$1"
}

value_exists() {
    match_against="$1"
    skip_index="$2"

    seen=0

    while IFS=' ' read -r n u; do
        i=$((i+1))

        [ "$match_against" = "name" ] && \
        [ "$name" = "$n" ] && \
        [ "$skip_index" != "$i" ] && {
            seen=1
            existing_name="$n"
            existing_url="$u"

            break
        }

        [ "$match_against" = "url" ] && \
        [ "$url" = "$u" ] && \
        [ "$skip_index" != "$i" ] && {
            seen=1
            existing_name="$n"
            existing_url="$u"

            break
        }

        [ $seen -eq 1 ]
    done < "$current"

    unset i

    [ $seen -eq 1 ] && return 0

    return 1
}

resolve_duplicates() {
    [ -f "$current" ] || {
        :> "$current"
        return
    }

    value_exists "name" "$index" && {
        msg "Duplicate name found in category:" \
            "$category" "$existing_name" "$existing_url"

        printf '\nEnter another name (or type Ctrl+C to abort): '
        new_name=$(read_input "$existing_name")

        [ -n "$new_name" ] && name="$new_name"

        resolve_duplicates
    }

    value_exists "url" "$index" && {
        msg "Duplicate URL found in category:" \
            "$category" "$existing_name" "$existing_url"

        printf '\nContinue anyway? [y/n]: '
        answer=$(read_input "")

        case $answer in
            'y'*|'Y'*) ;;
            *) die "Quitting." ;;
        esac

        unset answer
    }
}

remove_line_by_index() {
    sed -i "${1}d" "$current"
}

remove_empty_lines() {
    sed -i "/^$/d" "$current"
}

remove_empty_categories() {
    set +f
    set -f -- "$bookmark_dir/"*

    for file in "$@"; do
        [ -s "$file" ] || rm "$file"
    done
}

delete_entry() {
    while IFS=' ' read -r n u; do
        i=$((i+1))

        [ "$name" = "$n" ] && {
            url="$u"
            index="$i"
        }

        continue
    done < "$current"

    unset i

    [ -z "$index" ] && die "Bookmark $name not found in category $category."

    msg "Found bookmark:" \
        "$category" "$name" "$url"

    printf '\nDelete it? [y/n]: '
    answer=$(read_input "")

    case $answer in
        'y'*|'Y'*) ;;
        *) die "Quitting." ;;
    esac

    unset answer

    remove_line_by_index "$index"
    remove_empty_lines
    remove_empty_categories

    log "Bookmark deleted."
}

write_to_file() {
    printf '%s %s\n' "$name" "$url" >> "$current" || {
        die "Failed to write bookmark to file ${current##*/}."
    }
}

add_bookmark() {
    value_or_die "$category" "category"
    value_or_die "$name" "name"
    url_or_die "$url"

    resolve_duplicates

    write_to_file

    msg "Bookmark saved:" \
        "$category" "$name" "$url"
}

edit_bookmark() {
    value_or_die "$category" "category"
    value_or_die "$name" "name"
    file_or_die "$current"

    while IFS=' ' read -r n u; do
        i=$((i+1))

        [ "$name" = "$n" ] && {
            url="$u"
            index="$i"
        }

        continue
    done < "$current"

    unset i

    [ -z "$index" ] && die "Bookmark $name not found in category $category."

    msg "Editing bookmark:" \
        "$category" "$name" "$url"

    printf '\nEdit name (or press Enter to leave unchanged): '
    name=$(read_input "$name")

    printf '\nEdit URL (or press Enter to leave unchanged): '
    url=$(read_input "$url")

    resolve_duplicates

    remove_line_by_index "$index"
    remove_empty_lines
    write_to_file

    msg "Bookmark saved:" "$category" "$name" "$url"
}

open_bookmark() {
    [ -z "$BROWSER" ] && die "BROWSER is not set."

    value_or_die "$category" "category"
    value_or_die "$name" "name"
    file_or_die "$current"

    while IFS=' ' read -r n u; do
        [ "$name" = "$n" ] && {
            if [ -n "$u" ] && is_url "$u"; then
                command "$BROWSER" "$u" > /dev/null
                exit
            else
                die "Bookmark $name has an invalid or missing URL."
            fi
        }

        continue
    done < "$current"

    die "Bookmark $name not found in category."
}

list_bookmark() {
    if [ -n "$category" ]; then
        list_tree "$bookmark_dir/$category"
    else
        set +f
        set -f -- "$bookmark_dir/"*

        for c in "$@"; do
            [ -f "$c" ] || {
                log "No bookmarks found"
                continue
            }

            list_tree "$c"
        done
    fi
}

delete_bookmark() {
    value_or_die "$category" "category"
    file_or_die "$current"

    if [ -n "$name" ]; then
        delete_entry
    else
        printf 'Delete category %s? [y/n]: ' "$category"
        answer=$(read_input "")

        case $answer in
            'y'*|'Y'*) rm "$current" ;;
            *) die "Quitting." ;;
        esac

        unset answer
    fi
}

push_bookmark() (
    git_or_die

    cd "$BKM_DIR" || die "Failed to change directory to \$BKM_DIR."

    repo_or_die
    remote_or_die
    dirty_or_die

    git add .
    git commit -m "Update @ $(date '+%Y/%m/%d %H:%M')"
    git push
)

pull_bookmark() {
    git_or_die

    cd "$BKM_DIR" || die "Failed to change directory to \$BKM_DIR."

    repo_or_die
    remote_or_die

    is_dirty && {
        stashed=1

        git stash
    }

    git pull

    [ -n "$stashed" ] && {
        git stash apply

        push_bookmark

        unset stashed
    }
}

help() {
    log "bkm is a simple bookmark manager that uses plain text files to" \
        "store bookmarks under categories in a user-specified directory." \
        "The directory is defined by BKM_DIR in \$SHELL's startup file." "" \
        "Usage: bkm [options]..." "" \
        "add category.name url" \
        "    Add bookmark" \
        "    EXAMPLE: add \"archlinux.news\" \"https://www.archlinux.org/news/\"" "" \
        "edit category.name" \
        "    Edit bookmark" \
        "    EXAMPLE: edit \"archlinux.news\"" "" \
        "open category.name" \
        "    Open bookmark in \$BROWSER" \
        "    EXAMPLE: open \"archlinux.news\"" "" \
        "list -c <category>" \
        "    List bookmarks in category" \
        "    EXAMPLE: list \"archlinux\"" "" \
        "list" \
        "    List all bookmarks" "" \
        "delete category.name" \
        "    Delete bookmark from category" \
        "    EXAMPLE: delete \"archlinux.news\"" "" \
        "delete category" \
        "    Delete entire category" \
        "    EXAMPLE: delete \"archlinux\"" "" \
        "push" \
        "    Invokes git add, commit and push" \
        "    NOTE: Presumes that \$BKM_DIR is a git repository." "" \
        "pull" \
        "    Invokes git pull" \
        "    NOTE: Presumes that \$BKM_DIR is a git repository." ""
    exit
}

main() {
    [ -z "$BKM_DIR" ] && die "\$BKM_DIR is not set."

    bookmark_dir="${BKM_DIR%%/}/bkm"
    mkdir -p "$bookmark_dir"

    dotted="$2"
    printf '%s\n' "$dotted" | grep -q -e "\." || {
        dotted="$dotted."
    }

    action="$1"
    category=$(sanitize "${dotted%%.*}")
    name=$(sanitize "${dotted##*.}")
    url=$(sanitize "$3")
    current="$bookmark_dir/$category"
    index=""

    existing_name=""
    existing_url=""

    case $action in
        add) add_bookmark ;;
        edit) edit_bookmark ;;
        open) open_bookmark ;;
        list) list_bookmark ;;
        delete) delete_bookmark ;;
        push) push_bookmark ;;
        pull) pull_bookmark ;;
        *) help ;;
    esac
}

main "$@"
