#!/bin/sh -f

#
# bkm - bookmark manager
#

log() {
    printf '%s\n' "$@"
}

die() {
    log "$1"
    exit 1
}

nest() {
    log "├─ $1" \
        "│  $2"
}

mesg() {
    log "$1" "$2"
    nest "$3" "$4"
}

truncate() {
    set +f
    # shellcheck disable=2048,2086
    set -f -- $*

    printf '%s\n' "$*"
}

trim() {
    printf '%s\n' "$1" | sed -e "s/ //g"
}

sanitize() {
    str=$1
    str=$(truncate "$str")
    str=$(trim "$str")

    printf '%s\n' "$str"
}

read_input() {
    old_val=$1

    read -r "new_val"

    if [ -n "$new_val" ] && [ "$new_val" != "$old_val" ]; then
        new_val=$(sanitize "$new_val")
        printf '%s\n' "$new_val"
    else
        printf '%s\n' "$old_val"
    fi

    unset old_val
    unset new_val
}

is_url() {
    printf '%s' "$1" | grep -q -e "http://" -e "https://" -e "www." && {
        return 0
    }

    return 1
}

url_or_die() {
    is_url "${1:-""}" || die "URL is required and must have valid format."
}

value_or_die() {
    [ -n "$1" ] || die "Argument $2 is required."
}

file_or_die() {
    [ -f "$1" ] || die "Category ${1##*/} not found."
}

git_or_die() {
    command -v git > /dev/null || die "This command requires git to be installed."
}

repo_or_die() {
    command git rev-parse --is-inside-work-tree 1> /dev/null 2> /dev/null || {
        die "\$BKM_DIR is not a git repository."
    }
}

remote_or_die() {
    command git remote -v > /dev/null && {
        die "\$BKM_DIR remote repository not set."
    }
}

is_dirty() {
    git status --short > /dev/null && return 0

    return 1
}

dirty_or_die() {
    is_dirty || die "\$BKM_DIR git repository is clean."
}

list_tree() {
    file_or_die "$1"

    log "${1##*/}"

    while IFS=' ' read -r n u; do
        nest "$n" "$u"
    done < "$1"
}

handle_duplicate() {
    new_name="$1"
    new_url="$2"
    skip="${1:-"0"}"

    if [ -f "$current" ]; then
        seen="0"
        dup_name=""
        dup_url=""

        while IFS=' ' read -r n u; do

            [ "$new_name" = "$n" ] && {
                seen="1"
                dup_name="$n"
                dup_url="$u"
            }

            [ "$skip" = "0" ] && [ "$new_url" = "$u" ] && {
                mesg "Duplicate URL found in category." "$category" "$n" "$u"
                exit
            }
        done < "$current"

        [ $seen = "1" ] && {
            mesg "Duplicate name found in category." "$category" "$dup_name" "$dup_url"

            printf '\nEnter another name (or press Ctrl+C to abort): '

            name=$(read_input "$dup_name")

            [ "$skip" = "1" ] && [ "$name" = "$dup_name" ] && {
                mesg "Bookmark unchanged." "$category" "$old_name" "$old_url"
                exit
            }

            handle_duplicate "$name" "$new_url" "$skip"
        }

    else
        :> "$current"
    fi
}

add_bookmark() {
    value_or_die "$category" "category"
    value_or_die "$name" "name"
    url_or_die "$url"

    handle_duplicate "$name" "$url"

    printf '%s %s\n' "$name" "$url" >> "$current" || {
        die "Failed to write bookmark to file ${current##*/}."
    }

    mesg "Bookmark saved." "$category" "$name" "$url"
}

edit_bookmark() {
    value_or_die "$category" "category"
    value_or_die "$name" "name"
    file_or_die "$current"

    # delete line by index N from file
    # sed -i "Nd" file

    # delete empty lines in file
    # sed -i '/^$/d' file

    old_name=""
    old_url=""
    index=""

    while IFS=' ' read -r n u; do
        i=$((i+1))

        [ "$name" = "$n" ] && {
            old_name="$n"
            old_url="$u"
            index="$i"
        }

        continue
    done < "$current"

    [ -z "$index" ] && die "Bookmark $old_name not found in category."

    # printf '\nEdit name (or press Enter to leave unchanged): '
    # new_name=$(read_input "$old_name")

    # printf '\nEdit URL (or press Enter to leave unchanged): '
    # new_url=$(read_input "$old_url")

    # handle_duplicate "1"

    # if [ "$new_name" != "$old_name" ] || [ "$new_url" != "$old_url" ]; then
    # fi

    # mesg "Bookmark edited." "$category" "$name" "$url"
}

open_bookmark() {
    [ -z "$BROWSER" ] && die "BROWSER is not set."

    value_or_die "$category" "category"
    value_or_die "$name" "name"
    file_or_die "$current"

    while IFS=' ' read -r n u; do
        [ "$name" = "$n" ] && {
            if [ -n "$u" ] && is_url "$u"; then
                command "$BROWSER" "$u" > /dev/null
                exit
            else
                die "Bookmark $name has an invalid or missing URL."
            fi
        }

        continue
    done < "$current"

    die "Bookmark $name not found in category."
}

list_bookmark() {
    if [ -n "$category" ]; then
        list_tree "$bookmark_dir/$category"
    else
        set +f
        set -f -- "$bookmark_dir/"*

        for c in "$@"; do
            [ -f "$c" ] || {
                log "No bookmarks found"
                continue
            }

            list_tree "$c"
        done
    fi
}

delete_bookmark() {
    printf 'TODO\n'
}

push_bookmark() (
    git_or_die

    cd "$BKM_DIR" || die "Failed to change directory to \$BKM_DIR."

    repo_or_die
    remote_or_die
    dirty_or_die

    git add .
    git commit -m "Update @ $(date '+%Y/%m/%d %H:%M')"
    git push
)

pull_bookmark() {
    git_or_die

    cd "$BKM_DIR" || die "Failed to change directory to \$BKM_DIR."

    repo_or_die
    remote_or_die

    is_dirty && {
        stashed=1

        git stash
    }

    git pull

    [ -n "$stashed" ] && {
        git stash apply

        push_bookmark

        unset stashed
    }
}

help() {
    log "bkm is a simple bookmark manager that uses plain text files to" \
        "store bookmarks under categories in a user-specified directory." \
        "The directory is defined by BKM_DIR in \$SHELL's startup file." "" \
        "Usage: bkm [options]..." "" \
        "add category.name url" \
        "    Add bookmark" \
        "    EXAMPLE: add \"archlinux.news\" \"https://www.archlinux.org/news/\"" "" \
        "edit category.name" \
        "    Edit bookmark" \
        "    EXAMPLE: edit \"archlinux.news\"" "" \
        "open category.name" \
        "    Open bookmark in \$BROWSER" \
        "    EXAMPLE: open \"archlinux.news\"" "" \
        "list -c <category>" \
        "    List bookmarks in category" \
        "    EXAMPLE: list \"archlinux\"" "" \
        "list" \
        "    List all bookmarks" "" \
        "delete category.name" \
        "    Delete bookmark from category" \
        "    EXAMPLE: delete \"archlinux.news\"" "" \
        "delete category" \
        "    Delete entire category" \
        "    EXAMPLE: delete \"archlinux\"" "" \
        "push" \
        "    Invokes git add, commit and push" \
        "    NOTE: Presumes that \$BKM_DIR is a git repository." "" \
        "pull" \
        "    Invokes git pull" \
        "    NOTE: Presumes that \$BKM_DIR is a git repository." ""
    exit
}

main() {
    [ -z "$BKM_DIR" ] && die "\$BKM_DIR is not set."

    bookmark_dir="${BKM_DIR%%/}/bkm"
    mkdir -p "$bookmark_dir"

    action="$1"
    category=$(sanitize "${2%%.*}")
    name=$(sanitize "${2##*.}")
    url=$(sanitize "$3")
    current="$bookmark_dir/$category"

    case $action in
        add) add_bookmark ;;
        edit) edit_bookmark ;;
        open) open_bookmark ;;
        list) list_bookmark ;;
        delete) delete_bookmark ;;
        push) push_bookmark ;;
        pull) pull_bookmark ;;
        *) help ;;
    esac
}

main "$@"
